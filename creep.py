# Import packages
import pandas as pd
import numpy as np
import math
import json
import sympy as sym
import random
from scipy.interpolate import interp1d

########################################
# Parameter settings
with open('parameters.dat','r') as f:
    parameter = [x.split() for x in f.readlines()]

# filename generated by Neper
imputfile = parameter[1][0]

# Step
Δt = float(parameter[7][2])  # time increment [s]
step = int(parameter[9][2])  # number of steps

# Temperature [K]
T = float(parameter[13][2])

# Stress [Pa]
σxx = float(parameter[17][2])
σyy = float(parameter[18][2])
σzz = float(parameter[19][2])
σxy = float(parameter[20][2])
σyz = float(parameter[21][2])
σzx = float(parameter[22][2])
σ = np.array([[σxx, σxy, σzx], [σxy, σyy, σyz], [σzx, σyz, σzz]])

# Physical constant
kB = float(parameter[27][2])  # Boltzmann's constant [J K^-1]
Rth = float(parameter[29][2])  # Gas constant [J K^-1 mol^-1]

# Material properties for GB migration
b = float(parameter[34][2])  # Inter-atomic distance [m]
γ_GB = float(parameter[36][2])  # GB energy [J m^-2] 
λ = float(parameter[38][2]) * T  # Constant associated with atomic jump driving force
C = float(parameter[40][2]) / Δt  # Constant associated with atomic vibration frequency

# Material properties for GB diffusion
δ_GB = float(parameter[45][2])  # GB thickness [m]
Ω = float(parameter[47][2])  # Atomic volume [m^-3]
Q_GB = float(parameter[49][2])  # Activation energy for GB diffusion [J mol^-1]
D_GB0 = float(parameter[51][2])  # GB diffusion coefficient at T=0K [m^2 s^-1]
D_GB = D_GB0 * math.exp(-Q_GB / (Rth * T))  # GB diffusion coefficient [m^2 s^-1]

# Material properties for void nucleation and growth
δ_s = float(parameter[56][2])  # Surface thickness [m]
Q_s = float(parameter[58][2])  # Activation energy for surface diffusion [J mol^-1]
γ_s = float(parameter[60][2])  # Surface energy [J m^-2]
D_s0 = float(parameter[62][2])  # Maximum surface diffusion coefficient [m^2 s^-1]
D_s = D_s0 * math.exp(-Q_s / (Rth * T))  # Surface diffusion coefficient [m^2 s^-1]
ρ = float(parameter[64][2])  # Void nucleation constant

# Other parameters
M1 = 10 # Number used to truncate the calculation of an infinite series
M2 = 8
n_sim = 20  # Number of subdivisions for Simpson's rule
n_tip = 20 + 3 * M2  # Number of calculation points on a void tip
n_TL = 10 * M1  # Number of calculation points on TLs
ϕ = math.acos(γ_GB / (2 * γ_s))  # Dihedral angle Eq.(31)
D_GB_calc = (Ω * δ_GB * D_GB) / (kB * T)

aini = (4 * (1 - math.cos(ϕ)) * γ_s - (math.sin(ϕ)) ** 2 * γ_GB) * math.sin(ϕ) / \
    ((2 + math.cos(ϕ)) * (1 - math.cos(ϕ)) ** 2 * ((σ[0, 0] + σ[1, 1] + σ[2, 2]) / 3))
θ_ini = math.pi / 2 - ϕ
β_ini = math.tan(ϕ) * math.tan(θ_ini) * aini / math.cos(θ_ini)

V_calc1 = (2/3) * math.pi * (aini / math.sin(ϕ))**3 * (math.cos(ϕ) - 1)**2 * (math.cos(ϕ) + 2)
V_calc2 = (2/3) * math.pi * (math.sin(ϕ) / ((1 - math.cos(ϕ)) * math.sin(ϕ)))**3 * (math.cos(ϕ) - 1)**2 * (math.cos(ϕ) + 2)
h_calc = (3 * math.tan(ϕ)**2) / (2 * math.pi) * (math.sin(math.pi / 2 - ϕ)**2) / ((math.sin(math.pi / 2 - ϕ) + 2) * (math.sin(math.pi / 2 - ϕ) + 1))

sin_term = math.sin(math.pi / 2 - ϕ)
cos_term = math.cos(math.pi / 2 - ϕ)
a_calc = (2 * math.pi * math.tan(ϕ)) / 3 * (sin_term * (sin_term**3 - 3 * sin_term + 2)) / (cos_term**4)

ψ_calc = 3 / (2 * math.pi * math.tan(ϕ))
aratef_calc = (D_s * δ_s) / (kB * T)


########################################
# Import data of polycrystal generated by Neper
def convert_string(s):
    try:
        float(s)
    except ValueError:
        return s
    else:
        if float(s).is_integer():
            return int(float(s))
        else:
            return float(s)

def list_to_array(x):
    return np.abs(pd.DataFrame(x).fillna(0).to_numpy().astype(int))

# Import data from .tess file
with open(imputfile,'r') as f:
    data = [x.split() for x in f.readlines()]

data = [[convert_string(str) for str in subdata] for subdata in data]

# Import basic information
# Length of one period (length of the unit cell)
period_len = np.array(data[data.index(['**periodicity']) + 3])  # [x, y, z]
x_len, y_len, z_len = period_len[[0, 1, 2]]

# RVE data
center_index = [i for i, subdata in enumerate(data) if 'x0y0z0' in subdata][0]
vtx_RVE = np.array(data[center_index][1:4])  # vertex coordinates of the RVE
center = period_len / 2 + vtx_RVE  # center point coordinates of the RVE

# Vertices (including duplicate vertices)
vtx_index = data.index(['**vertex'])
nvtx = data[vtx_index + 1][0]  # Number of vertices
vtx = np.array(data[vtx_index + 2:vtx_index + 2 + nvtx])[:,:-1]  # [vertex id, x, y, z]

# Edges (including duplicate edges)
edg_index = data.index(['**edge'])
nedg = data[edg_index + 1][0]  # Number of edges
edg_vtx = np.array(data[edg_index + 2:edg_index + 2 + nedg])[:,:-1]  # [edge id, vertex id of endpoits]

# Faces (including duplicate faces)
fce_index = data.index(['**face'])
nfce = data[fce_index + 1][0]  # Number of faces
fce_edg = list_to_array(data[fce_index + 3:fce_index + 3 + 4 * nfce:4])  # [number of edge, edge id]
fce_edg[:,0] = np.arange(1, 1 + nfce)  # [face id, edge id]
max_edg_num = len(fce_edg[0]) - 1

# Polyhedrons (grains)
ply_index = data.index(['**polyhedron'])
nply = data[ply_index + 1][0]  # Number of polyhedrons
ply_fce = list_to_array(data[ply_index + 2:ply_index + 2 + nply])  # [polyhedron id, face number, face id]
max_fce_num = len(ply_fce[0]) - 2

# Import the information of duplicate elements
# Duplicate vertices
dvtx_index = data.index(['*vertex'], data.index(['*vertex']) + 1)
ndvtx = data[dvtx_index + 1][0] # Number of duplicate vertices
dvtx = np.array(data[dvtx_index + 2:dvtx_index + 2 + ndvtx])[:,0:2]  # [duplicate vtx id, original vtx id]
dic_vtx = dict(zip(range(1, nvtx + 1), range(1, nvtx + 1))) | dict(dvtx)  # {vtx id, original vtx id}

# Duplicate edges
dedg_index = data.index(['*edge'], data.index(['*edge']) + 1)
ndedg = data[dedg_index + 1][0] # Number of duplicate edges
dedg = np.array(data[dedg_index + 2:dedg_index + 2 + ndedg])[:,0:2]  # [duplicate edge id, original edge id]
dic_edg = dict(zip(range(1, nedg + 1), range(1, nedg + 1))) | dict(dedg)

# Duplicate faces
dfce_index = data.index(['*face'], data.index(['*face']) + 1)
ndfce = data[dfce_index + 1][0] # Number of duplicate faces
dfce = np.array(data[dfce_index + 2:dfce_index + 2 + ndfce])[:,0:2]  # [duplicate face id, original face id]
dic_fce = dict(zip(range(1, nfce + 1), range(1, nfce + 1))) | dict(dfce)


########################################
# Define variables and functions. Process polycrystalline data.
# Define variables
nQP = nvtx - len(dvtx)    # Number of Quadratic Points
QP = np.full((step + 1, nQP, 3), np.nan)   # QPs initially located in the center cell
QP[0] = (np.delete(vtx, dvtx[:,0] - 1, 0)[:, 1:] - vtx_RVE) % period_len +  vtx_RVE

nTL = nedg - len(dedg)  # Number of TLs

nGBF = nfce - len(dfce) # Number of GBFs

GBF_s = np.full((step + 1, nGBF), np.nan)  # Area of GBF
GBF_g = np.full((step + 1, nGBF, 3), np.nan)  # Center of gravity of GBF
GBF_nv = np.full((step + 1, nGBF, 3), np.nan)  # Normal vector of GBF

GBF_vtxc = np.full((step + 1, nGBF, max_edg_num, 2, 2), np.nan) # Vertex coordinates of GBF expressed in the complex coordinate system
# vtx_c[step, GBF id, TL id for each GBF (0~fce_edg_max - 1)] = [[x, y], [x, y]]

nvoid = np.full((step + 1, nGBF), np.nan)  # Number of voids in each GBF
nvoid[0] = np.full(nGBF, 0)

# GBF_state: State of voids on GBF.
# 1: void area fraction = 0 ~ 1.
# 2: void area fraction = 0 ~ 1. Void grwth is calculated by extrapolation of area fraction
# 3: void area fraction = 1.
GBF_state = np.ones((step + 1, nGBF), dtype=int)

v_δ = np.full((step + 1, nGBF), np.nan)  # Relative velocity of GBF

ω_GBF = np.full((step + 1, nGBF), np.nan)  # Void area fraction for each GBF
ω_GBF[0] = np.full(nGBF, 0.)

nG = nply  # Number of Grains 

ϵ = np.full((step + 1, 3, 3), np.nan)  # Strain
ϵ[0] = np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])

domain = np.full((step + 1, 3, 3), np.nan)  # Edges of RVE
domain[0] = np.array([[x_len, 0., 0.], [0., y_len, 0.], [0., 0., z_len]])

j_flux = np.full((step + 1, nGBF, max_edg_num * 2), np.nan) # Diffusion flux

void = [None] * (step + 1)  # Data about voids.
void[0] = [[] for _ in range(nGBF)]  # [radius, [center points], length of miner axis, center angle of sphere]

ω_all = np.full(step + 1, np.nan)  # Void area fraction for all GBFs
ω_all[0] = 0.

x_shift = np.array([-1, 0, 1, -1, 0, 1, -1, 0, 1, -1, 0, 1, -1, 0, 1, -1, 0, 1, -1, 0, 1, -1, 0, 1, -1, 0, 1])
y_shift = np.array([-1, -1, -1, 0, 0, 0, 1, 1, 1, -1, -1, -1, 0, 0, 0, 1, 1, 1, -1, -1, -1, 0, 0, 0, 1, 1, 1])
z_shift = np.array([-1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1])
xyz_shift = np.array([x_shift, y_shift, z_shift]).T


# QPs located in both the center cell and the surrounding cells in the initial state
# QP_27[step, id of cell (0~26), QP id] = [x, y, z]
QP_27 = np.full((step + 1, 27, nQP, 3), np.nan)
xyz_shift_len = np.matmul(xyz_shift, domain[0])
QP_27[0] = xyz_shift_len[:, np.newaxis, :] + QP[0]


# Process polycrystalline data.
# Calculate shift from basic cell
vtx_shift = ((vtx[:,1:] - vtx_RVE) // period_len).astype(int)  # [x_shift, y_shift, z_shift]
vtx_shift_val = np.matmul(vtx_shift, np.array([[1],[3],[9]])).flatten()  # x_shift + 3 * y_shift + 9 * z_shift

medg = np.mean(vtx[edg_vtx[:,1:] - 1,1:], axis=1)  # center point of edge
medg_shift = ((medg - vtx_RVE) // period_len).astype(int)  # [x_shift, y_shift, z_shift]
medg_shift_val = np.matmul(medg_shift, np.array([[1],[3],[9]])).flatten()

fce_medg = medg[fce_edg[:,1:] - 1]
fce_medg[np.where(fce_edg[:,1:] == 0)] = np.full(3, np.nan)
mfce = np.nanmean(fce_medg, axis=1)  # center point of face
mfce_shift = ((mfce - vtx_RVE) // period_len).astype(int)  # [x_shift, y_shift, z_shift]
mfce_shift_val = np.matmul(mfce_shift, np.array([[1],[3],[9]])).flatten()


# change id
original_vtx = np.setdiff1d(np.array(vtx[:,0], dtype=int), dvtx[:,0])  # extract original vtx id
QP_id = np.arange(1, nQP + 1)  # create new id (QP id)
dic_QP = dict(np.vstack([original_vtx, QP_id]).T)  # {original vtx id, QP id}
vtxid_to_QPid = np.array([dic_QP[dic_vtx[i]] for i in range(1, nvtx + 1)])  # [QP id]

original_edg = np.setdiff1d(edg_vtx[:,0], dedg[:,0])  # extract original edge id
TL_id = np.arange(1, nTL + 1)  # create new id (TL id)
dic_TL = dict(np.vstack([original_edg, TL_id]).T)  # {original edge id, TL id}
edgid_to_TLid = np.array([dic_TL[dic_edg[i]] for i in range(1, nedg + 1)])  # [TL id]

original_fce = np.setdiff1d(fce_edg[:,0], dfce[:,0])  # extract original face id
GBF_id = np.arange(1, nGBF + 1)  # create new id (GBF id)
dic_GBF = dict(np.vstack([original_fce, GBF_id]).T)  # {original face id, GBF id}
fceid_to_GBFid = np.array([dic_GBF[dic_fce[i]] for i in range(1, nfce + 1)])  # [GBF id]

Grain_id = np.arange(1, nG + 1)  # create new id (Grain id)


# Organize the relationship between QP, TL, GBF, and Grain.
# QPs that form TLs.
TL_QP_id = vtxid_to_QPid[edg_vtx[original_edg - 1,1:] - 1]  # Ids of QPs that form TL.
TL_QP_shift = vtx_shift_val[edg_vtx[original_edg - 1,1:] - 1] - medg_shift_val[original_edg - 1].reshape(nTL, 1) + 14  # Position of vertex relative to the cell in which center of the edge is located.

# TLs that form GBFs
GBF_TL_id = edgid_to_TLid[fce_edg[original_fce - 1,1:] - 1]  # Ids of TLs that form GBF.
GBF_TL_id[fce_edg[original_fce - 1,1:] == 0] = 0  # No data -> 0
GBF_TL_shift = medg_shift_val[fce_edg[original_fce - 1,1:] - 1] - mfce_shift_val[original_fce - 1].reshape(nGBF, 1) + 14  # Position of edge relative to the cell in which center of the face is located.
GBF_TL_shift[fce_edg[original_fce - 1,1:] == 0] = 0  # No data -> 0

# GBFs that form Grains
Grain_GBF_id = fceid_to_GBFid[ply_fce[:,2:] - 1]  # Ids of GBFs that form Grain.
Grain_GBF_id[ply_fce[:,2:] == 0] = 0  # No data -> 0
Grain_GBF_shift = mfce_shift_val[ply_fce[:,2:] - 1] + 14  # Position of face relative to the center cell.
Grain_GBF_shift[ply_fce[:,2:] == 0] = 0  # No data -> 0

# QPs that form GBFs
GBF_QP_id = TL_QP_id[GBF_TL_id - 1]  # Ids of QPs that form GBF.
GBF_QP_id[GBF_TL_id == 0] = [0, 0]  # No data -> 0
GBF_QP_shift = TL_QP_shift[GBF_TL_id - 1] - 14 + GBF_TL_shift[:, :, np.newaxis]  # Position of vertex relative to the cell in which center of the face is located.
GBF_QP_shift[GBF_TL_id == 0] = [0, 0]  # No data -> 0

# TLs that form QP.
QP_TL_id = np.array([np.where(TL_QP_id == i)[0] + 1 for i in QP_id])  # Ids of TLs that form QP.
QP_TL_shift = np.array([28 - TL_QP_shift[np.where(TL_QP_id == i)] for i in QP_id])  # Position of edge relative to the cell in which vertex is located.

# GBFs that form TL.
TL_GBF_id = np.array([np.where(GBF_TL_id == i)[0] + 1 for i in TL_id])  # Ids of GBFs that form TL
TL_GBF_shift = np.array([28 - GBF_TL_shift[np.where(GBF_TL_id == i)] for i in TL_id])  # Position of face relative to the cell in which center of the edge is located.

# GBF that form Grain.
GBF_Grain_id = np.array([np.where(Grain_GBF_id == i)[0] + 1 for i in GBF_id])  # Ids of Grains that form GBF.
GBF_Grain_shift = np.array([28 - Grain_GBF_shift[np.where(Grain_GBF_id == i)] for i in GBF_id])  # Postion of Grains relative to the cell in which center of face is located. 

# Find adjacent QP.
def find_next_QP(x):  # x : QP id
    i, j = np.where(TL_QP_id == x)[0], np.where(TL_QP_id == x)[1]
    
    return TL_QP_id[i, j - 1], 14 + TL_QP_shift[i, j - 1] - TL_QP_shift[i, j]

find_next_QP2 = np.frompyfunc(find_next_QP, 1, 2)  # function that get id and position of adjacent QP

QP_next_id, QP_next_shift = find_next_QP2(QP_id)  # Id and position of adjacent QPs relative to the cell in which QP is located.
QP_next_id, QP_next_shift = np.stack(QP_next_id), np.stack(QP_next_shift)

# Find adjacent GBF.
GBF_next_id = TL_GBF_id[GBF_TL_id - 1]  # Ids of target GBF and its adjacent GBFs
GBF_next_shift = TL_GBF_shift[GBF_TL_id - 1] + GBF_TL_shift[:, :, np.newaxis] - 14  # Postions of target GBF and its adjacent GBFs
GBF_next_id[GBF_TL_id == 0], GBF_next_shift[GBF_TL_id == 0] = [0, 0, 0], [0, 0, 0]  # No data -> 0
GBF_next_id, GBF_next_shift = GBF_next_id.tolist(), GBF_next_shift.tolist()

# Delete id and position of target GBF.
for i, (id1, shift1) in enumerate(zip(GBF_next_id, GBF_next_shift), 1):
    for id2, shift2 in zip(id1, shift1):
        if id2 == [0, 0, 0]:
            id2.remove(0)
            shift2.remove(0)
        else:
            a = id2.index(i)
            del id2[a]
            del shift2[a]

GBF_next_id = np.array(GBF_next_id).reshape(nGBF, 2 * max_edg_num)
GBF_next_shift = np.array(GBF_next_shift).reshape(nGBF, 2 * max_edg_num)

# If adjacent GBF is fully covered by voids(ω = 1), eneter tip stress of void.
# If adjacent GBF is not fully covered by voids, value is 0.
GBF_next_status = np.zeros_like(GBF_next_id, dtype=float)

# Find adjacent Grain.
Grain_next_id = GBF_Grain_id[Grain_GBF_id - 1]  # Ids of target Grain and its adjacent Grain
Grain_next_shift = GBF_Grain_shift[Grain_GBF_id - 1] + Grain_GBF_shift[:, :, np.newaxis] - 14  # Postions of target Grain and its adjacent Grains
Grain_next_id[Grain_GBF_id == 0] = [0, 0]
Grain_next_shift[Grain_GBF_id == 0] = [0, 0]
Grain_next_id = Grain_next_id.tolist()
Grain_next_shift = Grain_next_shift.tolist()

# Delete id and position of target Grain.
for i, (id1, shift1) in enumerate(zip(Grain_next_id, Grain_next_shift), 1):
    for id2, shift2 in zip(id1, shift1):
        if id2 == [0, 0]:
            id2.remove(0)
            shift2.remove(0)
        else:
            a = id2.index(i)
            del id2[a]
            del shift2[a]
            
Grain_next_id = np.array(Grain_next_id).reshape(nG, max_fce_num)
Grain_next_shift = np.array(Grain_next_shift).reshape(nG, max_fce_num)

# Coordinates of QPs that form GBF.
GBF_coord = QP_27[0, GBF_QP_shift - 1, GBF_QP_id - 1]
GBF_coord[GBF_QP_id == 0] = np.array([np.nan, np.nan, np.nan])

# Define function that use when caluculate area and centroid of GBF.
def unit_vector(vector):
    return np.array(vector) / np.linalg.norm(vector)

def trianglearea(a, b, c):  # a, b, c : array [x,y,z]
    return 0.5 * np.linalg.norm(np.cross(a - c, b - c))

def calc_GBF_data(x, is0_):  # x: GBF_id - 1. is0 : step
    # Calculate Area of GBF
    if np.any(np.isnan(GBF_coord[x])):
        index = np.where(np.isnan(GBF_coord[x]))[0][0]
    else:
        index = max_edg_num

    X = GBF_coord[x,:index]
    X_reshape = X.reshape(index * 2, 3)
    G = np.mean(X_reshape, axis=0)
    GBF_s[is0_, x] = sum(map(lambda p: trianglearea(G, p[0], p[1]), X))

    # Calculate centroid of GBF
    GBF_g[is0_, x] = sum(map(lambda p: trianglearea(G, p[0], p[1]) / GBF_s[is0_, x] * (G + p[0] + p[1]) / 3, X))

    # calculate normal vector
    points = np.unique(X_reshape, axis=0) * 100000
    Σx = sum(points[:,0])
    Σy = sum(points[:,1])
    Σz = sum(points[:,2])
    Σx2 = sum(points[:,0] ** 2)
    Σy2 = sum(points[:,1] ** 2)
    Σz2 = sum(points[:,2] ** 2)
    Σxy = sum(points[:,0] * points[:,1])
    Σyz = sum(points[:,1] * points[:,2])
    Σzx = sum(points[:,2] * points[:,0])
    A = np.array([[Σx2, Σxy, Σzx], [Σxy, Σy2, Σyz], [Σzx, Σyz, Σz2]])
    b = np.array([Σx, Σy, Σz])
    t = np.linalg.pinv(A).dot(b)
    GBF_nv[is0_, x] = t / np.linalg.norm(t)

    # Convert the coordinates of QPs into complex coordinates centered around the centroid of the GBF.
    u, v, w = GBF_nv[is0_, x]
    if w != 0. and (u != 0. or v != 0.):
        base1, base2 = unit_vector([-v, u, 0.]), unit_vector([-u, -v, (u ** 2 + v ** 2) / w])
    elif v != 0. and (u != 0. or w != 0.):
        base1, base2 = unit_vector([-w, 0., u]), unit_vector([-u, (u ** 2 + w ** 2) / v, -w])
    elif u != 0. and (v != 0. or w != 0.):
        base1, base2 = unit_vector([0., -w, v]), unit_vector([(v ** 2 + w ** 2) / u, -v, -w])
    elif w != 0.:
        base1, base2 = np.array([0, 1, 0]), np.array([1, 0, 0])
    elif v != 0.:
        base1, base2 = np.array([0, 0, 1]), np.array([1, 0, 0])
    else:
        base1, base2 = np.array([0, 0, 1]), np.array([0, 1, 0])
    
    base_vectors = np.array([base1, base2, GBF_nv[is0_, x]])
    inv = np.linalg.pinv(base_vectors)
    GBF_vtxc[is0_, x, :index] = np.matmul(X_reshape - GBF_g[is0_, x], inv)[:,:2].reshape(index, 2, 2)

for i in range(nGBF):
    calc_GBF_data(i, 0)


def plfoot(x, p1, p2):  # Foot of the perpendicular.
    t = (np.dot(p1 - x, p1 - x) - np.dot(p1 - x, p2 - x)) / np.dot(p1 - p2, p1 - p2)
    return p1 + t * (p2 - p1)

def pldist(x, p1, p2):  # Distance between a point and a line segment.
    t = (np.dot(p1 - x, p1 - x) - np.dot(p1 - x, p2 - x)) / np.dot(p1 - p2, p1 - p2)
    if 0 <= t <= 1:
        return np.linalg.norm(p1 + t * (p2 - p1) - x)
    elif t < 0:
        return np.linalg.norm(p1 - x)
    else:
        return np.linalg.norm(p2 - x)

def pldist2(x, p1, p2):  # Distance between a point and a straight line.
    t = (np.dot(p1 - x, p1 - x) - np.dot(p1 - x, p2 - x)) / np.dot(p1 - p2, p1 - p2)
    return np.linalg.norm(p1 + t * (p2 - p1) - x)

def calc_dividing_points(p1, p2, num):  # calculate coordinates of dividing points.
    return p1 * np.arange(num, -1, -1)[:,np.newaxis] / num + p2 * np.arange(num + 1)[:,np.newaxis] / num


# Define dG_dx, dG_dy and dG_dz in order to calculate ∂G/∂x, ∂G/∂y and ∂G/∂z (Eq.(3)).
def define_function():
    global dG_dx, dG_dy, dG_dz

    # x, y, z: Variables.  X0, Y0, Z0: Coordinates of target QP.  X1, X2, ,,,Z3, Z4 : Coordinates of adjacent QPs.
    x, y, z, X0, X1, X2, X3, X4, Y0, Y1, Y2, Y3, Y4, Z0, Z1, Z2, Z3, Z4 = \
        sym.symbols('x, y, z, X0, X1, X2, X3, X4, Y0, Y1, Y2, Y3, Y4, Z0, Z1, Z2, Z3, Z4') 

    def norm(t):
        return (sum(map(lambda x: x**2, t))) ** 0.5

    O_xyz = np.array([x, y, z])
    O = np.array([X0, Y0, Z0])  # Coordinates of target QP.
    X = np.array([[X1, Y1, Z1],[X2, Y2, Z2], [X3, Y3, Z3], [X4, Y4, Z4]])  # Coordinates of adjacent QPs.

    # Eq.(1)
    G = γ_GB * 0.5 * (norm(np.cross(X[0] - O_xyz, X[1] - O_xyz)) + norm(np.cross(X[0] - O_xyz, X[2] - O_xyz)) + norm(np.cross(X[0] - O_xyz, X[3] - O_xyz)) +\
                    norm(np.cross(X[1] - O_xyz, X[2] - O_xyz)) + norm(np.cross(X[1] - O_xyz, X[3] - O_xyz)) + norm(np.cross(X[2] - O_xyz, X[3] - O_xyz)))
    
    dG_dx_f = sym.diff(G, x).subs({x: O[0], y: O[1], z: O[2]})
    dG_dy_f = sym.diff(G, y).subs({x: O[0], y: O[1], z: O[2]})
    dG_dz_f = sym.diff(G, z).subs({x: O[0], y: O[1], z: O[2]})

    args = [[X0, Y0, Z0], [[X1, Y1, Z1],[X2, Y2, Z2], [X3, Y3, Z3], [X4, Y4, Z4]]]
    dG_dx, dG_dy, dG_dz = sym.lambdify(args, dG_dx_f), sym.lambdify(args, dG_dy_f), sym.lambdify(args, dG_dz_f)

define_function()


# Function that calculate grain growth due to GB migration
def static(x, is0_):  # x: QP id - 1
    # O:QP coordinates, X:adjacent QPs coordinates
    O = QP[is0_, x]
    X = QP_27[is0_, QP_next_shift[x] - 1, QP_next_id[x] - 1]

    n_G = np.array([- dG_dx(O,X), - dG_dy(O,X), - dG_dz(O,X)])  # Eq.(3). [n_x, n_y, n_z]
    p_G = np.linalg.norm(n_G)
    q = n_G / p_G  # Eq.(6). Direction of movement of O.

    ΔOXiXj = np.array([trianglearea(O, X[0], X[1]), trianglearea(O, X[0], X[2]), trianglearea(O, X[0], X[3]),\
                       trianglearea(O, X[1], X[2]), trianglearea(O, X[1], X[3]), trianglearea(O, X[2], X[3])])
    Sm = sum(ΔOXiXj)
    
    def calc_normal_vector(p0, p1):
        return np.cross((p0 - O), (p1 - O)) / np.linalg.norm(np.cross((p0 - O), (p1 - O)))
    
    normal_vectors = np.array([calc_normal_vector(X[0], X[1]), calc_normal_vector(X[0], X[2]), calc_normal_vector(X[0], X[3]),\
                               calc_normal_vector(X[1], X[2]), calc_normal_vector(X[1], X[3]), calc_normal_vector(X[2], X[3])])

    V_per_len = sum(ΔOXiXj * abs(np.dot(normal_vectors, q)))  # The swept volume when O moves one unit length. Sr in Mathemaica

    ΔV_Δt = C * Sm * b * (1 - math.exp(- b ** 2 * λ * p_G / (kB * T * Sm)))  # Eq.12.

    return ΔV_Δt / V_per_len * q


# Define function that use when caluculating surface diffusion
def define_function2():
    global aratef

    a, b, x = sym.symbols('a, b, x')

    Lf = 2 * math.pi * a * sym.cos(x)
    Lf1 = sym.diff(Lf, x)

    Sf1 = (a ** 2 * sym.sin(x) ** 2 + b ** 2 * sym.cos(x) ** 2) ** (1 / 2)
    Sf2 = sym.diff(Sf1, x)

    μf = - γ_s * Ω * (b / (a * (a ** 2 * sym.sin(x) ** 2 + b ** 2 * sym.cos(x) ** 2) ** (1 / 2)) + (a * b) / (a ** 2 * sym.sin(x) ** 2 + b ** 2 * sym.cos(x) ** 2) ** (3 / 2))
    μf1 = sym.diff(μf, x)
    μf2 = sym.diff(μf1, x)

    aratef_ = - aratef_calc * ((μf1 / Lf) * Lf1 * (1 / Sf1 ** 2) - μf1 * Sf2 * (1 / Sf1 ** 3) + μf2 * (1 / Sf1 ** 2))

    aratef = sym.lambdify([a, b, x], aratef_)

define_function2()


def execution(is_):
    global GBF_coord, check

    # calculate grain growth due to GB migration
    v_QP_m = np.array([static(i, is_) for i in range(nQP)])

    # calculate length of TLs
    TL_length = np.linalg.norm(QP_27[is_, TL_QP_shift[:,0] - 1, TL_QP_id[:,0] - 1] -\
                            QP_27[is_, TL_QP_shift[:,1] - 1, TL_QP_id[:,1] - 1], axis=1)

    # calculate center points  of TLs
    TL_center = 0.5 * (QP_27[is_, TL_QP_shift[:,0] - 1,TL_QP_id[:,0] - 1] +\
                    QP_27[is_, TL_QP_shift[:,1] - 1, TL_QP_id[:,1] - 1])

    # calculate center points  of GBFs
    GBF_center = np.nanmean(GBF_coord.reshape(nGBF, 2 * max_edg_num, 3), axis=1)

    # calculate diffusion flux from GBFi(target GBF) to GBFj(next GBF)
    def calc_j(targetGBF, _next_GBF_id, _next_GBF_shift, _TL_id, _GBF_TL_shift):
        if _next_GBF_id == 0:
            return np.nan
        
        l = TL_length[_TL_id - 1]  # length of TL
        M = TL_center[_TL_id - 1] + np.matmul(xyz_shift[_GBF_TL_shift - 1], domain[is_])  # center point of TL.
        Gi = GBF_center[targetGBF - 1]  # center point of GBF.
        Gj = GBF_center[_next_GBF_id - 1] + np.matmul(xyz_shift[_next_GBF_shift - 1], domain[is_])  # center point of adjacent GBF.

        # Calculate diffusion flux from GBFi to GBFj. Eq.(21)
        return - l / (kB * T * (np.linalg.norm(Gi - M) + np.linalg.norm(M - Gj))) * \
            (GBF_nv[is_, targetGBF - 1] @ σ @ GBF_nv[is_, targetGBF - 1] * (D_GB * δ_GB if GBF_state[is_, targetGBF - 1] != 3 else D_s * δ_s) - \
            GBF_nv[is_, _next_GBF_id - 1] @ σ @ GBF_nv[is_, _next_GBF_id - 1] * (D_GB * δ_GB if GBF_state[is_, _next_GBF_id - 1] != 3 else D_s * δ_s))

    temp1 = np.repeat(GBF_TL_id, 2).reshape(nGBF, 2 * max_edg_num)
    temp2 = np.repeat(GBF_TL_shift, 2).reshape(nGBF, 2 * max_edg_num)

    j_flux[is_] = np.array([[calc_j(a, b1, c1, d1, e1) for b1, c1, d1, e1 in zip(b, c, d, e)]\
                            for a, b, c, d, e in zip(GBF_id, GBF_next_id, GBF_next_shift, temp1, temp2)])


    # Calculate relative velocity of GBF. Eq.(23)
    v_δ[is_] = - Ω * np.nansum(j_flux[is_], axis=1) / GBF_s[is_]

    # Calculate strain rate of RVE. Eq.(24)
    ϵ_rate = sum(np.array([np.tensordot(i, i, axes=0) for i in GBF_nv[is_]]) * GBF_s[is_].reshape(nGBF, 1, 1) * v_δ[is_].reshape(nGBF, 1, 1)) /\
        (np.linalg.norm(domain[is_, 0]) * np.linalg.norm(domain[is_, 1]) * np.linalg.norm(domain[is_, 2]))

    # Calculte the translational velocity vectors of the diffusion centres.
    # Change normal vector direction and calculate ralative GB velocity of each grain toward outside grains.
    Grain_fce_center = xyz_shift[Grain_GBF_shift - 1] @ domain[is_] + GBF_center[Grain_GBF_id - 1]
    Grain_fce_center[Grain_GBF_id == 0] = [np.nan, np.nan, np.nan]  # Center point of face.
    Grain_center = np.nanmean(Grain_fce_center, axis=1)  # Center point of Grain

    Grain_GBF_nv = GBF_nv[is_, Grain_GBF_id - 1]  # Normal vector of GBF.
    Grain_GBF_nv[Grain_GBF_id == 0] = [np.nan, np.nan, np.nan]

    out_vector = np.subtract(Grain_fce_center, Grain_center[:,np.newaxis,:])  # Vectors. Start: center point of grain. End: center point of GBF. 
    Grain_GBF_nv[np.sum(out_vector * Grain_GBF_nv, axis=2) < 0] *= -1  # Direction of all vectors are toward the outside of grain.

    Grain_v_δ = v_δ[is_,Grain_GBF_id - 1]
    Grain_v_δ[Grain_GBF_id == 0] = np.nan  # magnitudes of ralative GB velocity of each grain
    Grain_v_δ = Grain_GBF_nv * Grain_v_δ[:,:,np.newaxis]  # ralative GB velocity of each grain toward outside grains. "Gvδ" in Mathematica.

    # Calculate weight of each GBF. (Eq.27)
    Grain_GBF_s = GBF_s[is_, Grain_GBF_id - 1]
    Grain_GBF_s[Grain_GBF_id == 0] = np.nan  # Area of GBF of each grain.
    Grain_GBF_weight = Grain_GBF_s / np.nansum(Grain_GBF_s, axis=1)[:,np.newaxis]  # weight of each GBF.(Eq.27) "GGBwait" in Mathematica.

    # Determine the coefficients, k, of a system of simultaneous equations
    k0 = np.eye(nG)
    for i in range(nG):
        tempi  = Grain_next_id[i, Grain_next_id[i] != 0]
        tempw = Grain_GBF_weight[i, ~np.isnan(Grain_GBF_weight[i])]
        if len(tempi) == len(set(tempi)):
            k0[i, tempi - 1] = - tempw
        else:
            for j in range(len(tempi)):  # Adjacent grains are in contact across more than two GBF.
                k0[i, tempi[j] - 1] -= tempw[j]

    dropn = 1  # Grain id that set velocity = 0.
    dropn_v = np.array([0, 0, 0])  # translational velocity of Grain "dropn".
    dropn -= 1  # Corresponding index = id - 1
    k = np.delete(np.delete(k0, dropn, 0), dropn, 1)  # delete elements that correspond to the grain which velocity set to zero.

    # Solve a system of simultaneous equations.
    # Σwvn: Total of GBF velocity vectors of each grain. The first term on the right-hand side of Eq.26.
    # gap_sum: Sum of velocity vector differences arising from adjacent grains located outside the RVE.
    Σwvn = np.delete(np.nansum(Grain_GBF_weight[:,:,np.newaxis] * Grain_v_δ, axis=1), dropn, 0)
    gap_sum = np.array([[[0, 0, 0] if s == 0 else list(w * xyz_shift[s - 1] @ (domain[is_] @ ε_rate)) for s, w in zip(shift, weight)] \
        for shift, weight in zip(Grain_next_shift, Grain_GBF_weight)])
    gap_sum = np.sum(gap_sum, axis=1)
    gap_sum = np.delete(gap_sum, dropn, 0)
    Gv = np.insert(np.linalg.inv(k) @ (Σwvn + gap_sum), dropn, dropn_v, axis=0) # translational velocities of grains

    # Calculate translational velocities of GBF.
    Grain_center_o = Grain_center[GBF_Grain_id[:, 0] - 1] + xyz_shift[GBF_Grain_shift[:, 0] - 1] @ domain[is_]  # One of the grain that forms GBF.
    Grain_center_i = Grain_center[GBF_Grain_id[:, 1] - 1] + xyz_shift[GBF_Grain_shift[:, 1] - 1] @ domain[is_]  # The other grain that forms GBF.

    v_GBF_m = v_QP_m[GBF_QP_id.reshape(nGBF, max_edg_num * 2) - 1]  # Calculate GBF velocity due to GB migration.
    v_GBF_m[GBF_QP_id.reshape(nGBF, max_edg_num * 2) == 0] = np.full(3,np.nan) # No data -> np.nan
    v_GBF_m = np.nanmean(v_GBF_m, axis=1)

    judge_move_direction = np.array([np.dot(i, j) for i, j in zip(Grain_center_o - GBF_center, v_GBF_m)]) # If value >= 0, GBF move toward Grain o.
    judge_move_direction = np.where(judge_move_direction >= 0, 0, 1)  # 0: GBF move toward Grain o. 1: GBF move toward Grain i.

    # If GBF move toward Grain o, μo > μi. If GBF move toward Grain i, μo < μi
    # Grain that has higher chemical potential.
    μ_high_id, μ_high_shift = GBF_Grain_id[GBF_id - 1, judge_move_direction], GBF_Grain_shift[GBF_id - 1, judge_move_direction]
    # Grain that has lower chemical potential.
    μ_low_id, μ_low_shift = GBF_Grain_id[GBF_id - 1, judge_move_direction - 1], GBF_Grain_shift[GBF_id - 1, judge_move_direction - 1]

    # Calculate translational velocity of Grain considering periodic condition.
    v_high = np.array([Gv[i - 1] + xyz_shift[s - 1] @ (domain[is_] @ ε_rate) for i, s in zip(μ_high_id, μ_high_shift)])
    v_low = np.array([Gv[i - 1] + xyz_shift[s - 1] @ (domain[is_] @ ε_rate) for i, s in zip(μ_low_id, μ_low_shift)])

    # Calculate center points coordinates of Grains considering periodic condition.
    c_high = np.array([Grain_center[i - 1] + xyz_shift[s - 1] @ domain[is_] for i, s in zip(μ_high_id, μ_high_shift)])
    c_low = np.array([Grain_center[i - 1] + xyz_shift[s - 1] @ domain[is_] for i, s in zip(μ_low_id, μ_low_shift)])

    v_GBF = np.array([v_high[i] if np.dot(v_high[i] - v_low[i], c_high[i] - c_low[i]) > 0\
        else v_low[i] for i in range(nGBF)]) # translational velocities of GBF. "GBv" in Mahtemaitca.


    # Calculate translational velocities of TLs.
    v_TL = np.mean(v_GBF[TL_GBF_id - 1] + xyz_shift[TL_GBF_shift - 1] @ (domain[is_] @ ε_rate), axis=1)
    v_QP = np.mean(v_TL[QP_TL_id - 1] + xyz_shift[QP_TL_shift - 1] @ (domain[is_] @ ε_rate), axis=1)


    # Deformation: updates
    ϵ[is_ + 1] = ϵ[is_] + ϵ_rate * Δt

    domain[is_ + 1] = domain[0] + np.array([domain[0, 0, 0] * ϵ[is_ + 1, 0], domain[0, 1, 1] * ϵ[is_ + 1, 1], domain[0, 2, 2] * ϵ[is_ + 1, 2]])

    QP[is_ + 1] = QP[is_] + v_QP_m * Δt + v_QP * Δt

    xyz_shift_len = np.matmul(xyz_shift, domain[is_ + 1])
    QP_27[is_ + 1] = xyz_shift_len[:, np.newaxis, :] + QP[is_ + 1]

    GBF_coord = QP_27[is_ + 1, GBF_QP_shift - 1, GBF_QP_id - 1]
    GBF_coord[GBF_QP_id == 0] = np.array([np.nan, np.nan, np.nan])

    for i in range(nGBF):
        calc_GBF_data(i, is_ + 1)



    # Void nucleation
    new_void_num_decimal = ρ * GBF_s[is_] * (np.abs(v_δ[is_]) ** (4/3)) * Δt
    new_void_num_decimal[v_δ[is_] <= 0] = 0
    new_void_num_decimal[GBF_state[is_] != 1] = 0

    def nucleation(GBFi):  # GBFi: id - 1
        
        temp = void[is_][GBFi]
        
        if new_void_num_decimal[GBFi] == 0:
            return temp
        
        # Decide number of new voids.
        # 0 <= random.random() < 1
        if math.modf(new_void_num_decimal[GBFi])[0] > random.random():
            new_void_num = math.modf(new_void_num_decimal[GBFi])[1] + 1
        else:
            new_void_num = math.modf(new_void_num_decimal[GBFi])[1]
        
        if new_void_num == 0:
            return temp
        
        vtxc0 = GBF_vtxc[is_, GBFi, ~np.isnan(GBF_vtxc[is_, GBFi])].reshape(-1, 2, 2)  # QPs coordinates
        area = np.array([abs(np.cross(x[0], x[1])) for x in vtxc0])  # Triangle area * 2.
        culm_area_fraction = np.cumsum(area) / sum(area)
        
        def determine_center_new_void():
            try_num = 0
            void_TL_dist = [1]
            
            while sum(void_TL_dist) > 0 or sum(void_dist) > 0:
                new_void_site = np.count_nonzero(culm_area_fraction < random.random())
                
                randoma = random.random()
                randomb = random.random()
                center_new_void = 0.9 * randoma * (randomb * vtxc0[new_void_site, 0] + (1 - randomb) * vtxc0[new_void_site, 1])
                
                void_TL_dist = [0 if pldist(center_new_void, x[0], x[1]) > aini else 1 for x in vtxc0]
                
                if len(temp) == 0:
                    void_dist = [0]
                else:
                    void_dist = [0 if np.linalg.norm(center_new_void - x[1]) > (aini * 2. + x[0]) else 1 for x in temp]
                
                try_num += 1
                if try_num > 500:
                    # print(GBFi + 1, " nucleationE")
                    GBF_state[is_ + 1:, GBFi] = 2
                    break
            
            return list(center_new_void)
            
        for i in range(int(new_void_num)):
            center_new_void = determine_center_new_void()
            
            ntime = random.random()
            temp = temp + [[aini, center_new_void, β_ini, θ_ini, ntime]]
        
        return temp

    void_temp = [nucleation(i) for i in range(nGBF)]


    # Function that calculate void growth
    def growth(GBFi):
        if GBF_state[is_ + 1, GBFi] != 1:
            return void_temp[GBFi]
        
        nv = len(void_temp[GBFi])  # Number of void.
        if nv == 0:
            return void_temp[GBFi]
        
        # void data
        a = np.array([item[0] for item in void_temp[GBFi]])  # radius of voids
        c = np.array([item[1] for item in void_temp[GBFi]])  # center of voids
        β = np.array([item[2] for item in void_temp[GBFi]])  # Length of miner axis
        ψ = np.array([item[3] for item in void_temp[GBFi]])  # center angle of sphere.
        h = β * (1 - np.sin(ψ))  # void height.
        ntime = np.array([1 if len(element) == 4 else element[4] for element in void_temp[GBFi]])
        V = 2 * math.pi * β ** 3 * (np.sin(ψ) ** 3 - 3 * np.sin(ψ) + 2) / (3 * math.tan(ϕ) ** 2 * np.tan(ψ) ** 2)

        # data about GBF
        S0 = GBF_s[is_, GBFi]

        GBF_nv0 = GBF_nv[is_, GBFi]

        R = math.sqrt(S0 / math.pi)
        
        v_δ0 = v_δ[is_, GBFi]
        
        vtxc0 = GBF_vtxc[is_, GBFi, ~np.isnan(GBF_vtxc[is_, GBFi])].reshape(-1, 2, 2)  # Vertices coordinates.
        
        TL_vector = vtxc0[:,0] - vtxc0[:,1]
        TL_length0 = np.linalg.norm(TL_vector, axis=1)  # Length of TL
        nTL0 = len(TL_length0)  # Number of TLs

        j_flux0 = j_flux[is_, GBFi, ~np.isnan(j_flux[is_,GBFi])]
        
        # If adjacent GBF is fully covered void -> sigma_tip_next = stress at the tip of void located in adjacent GBF.
        # Otherwise, sigma_tip_next = 0.
        sigma_tip_next = [min(GBF_next_status[GBFi, 2 * i], GBF_next_status[GBFi, 2 * i + 1]) if (GBF_next_status[GBFi, 2 * i] != 0 and GBF_next_status[GBFi, 2 * i + 1] != 0)\
            else max(GBF_next_status[GBFi, 2 * i], GBF_next_status[GBFi, 2 * i + 1]) for i in range(nTL0)]

        # stress at the tip of void
        σ_tip = (γ_s * math.tan(ϕ) * np.tan(ψ) / β) * (math.sin(ϕ) / np.cos(ψ)) * (1 + math.cos(ϕ) ** 2 / np.sin(ψ) ** 2)  # σtip[nv]=stress
        
        # σ0: special solution
        def σ0(x, y):  # x: [x1, x2,,, xn(n:number of calculation points)]  y: [y1, y2,,, yn]
            return - (x ** 2 + y ** 2) * v_δ0 / (4 * D_GB_calc)
        
        def σ0_dx(x):  # x: [x1, x2,,, xn(n:number of calculation points)]  y: [y1, y2,,, yn]
            return - x * v_δ0 / (2 * D_GB_calc)
        
        def σ0_dy(y):  # x: [x1, x2,,, xn(n:number of calculation points)]  y: [y1, y2,,, yn]
            return - y * v_δ0 / (2 * D_GB_calc)
        
        def σ0_dr(r, angle, x0, y0):  # x0, y0: center point of void.
            return -(v_δ0 / (2 * D_GB_calc)) * (r + x0 * np.cos(angle) + y0 * np.sin(angle))
        

        # Coefficient of unkwown constant in σh. σh: general solution of homogeneous equation.
        def σh(x, y):
            # x:[x_1, x_2, x_3,,,x_number of calculation points] dtype = ndarray
            # y:[y_1, y_2, y_3,,,y_number of calculation points] dtype = ndarray
            
            npoint = len(x)  # number of calculation points

            X00 = np.full((npoint, 1), 1.0)  # [[1.], [1.], [1.],,,[1.]]

            f = ((x / R) + 1j * (y / R))[:, np.newaxis] ** np.arange(1, M1 + 1)

            g = (((x[:, np.newaxis] / a - c[:, 0] / a) + 1j * (y[:, np.newaxis] / a - c[:, 1] / a))[:, :, np.newaxis] ** np.arange(- 1, - M2 - 1, - 1)).reshape(npoint, -1)

            h = 0.5 * np.log((x[:, np.newaxis] - c[:, 0]) ** 2 + (y[:, np.newaxis] - c[:, 1]) ** 2) - math.log(R)

            # return 2d array [[Coefficients at (x1, y1)], [Coefficients at (x2, y2)],,,[Coefficients at (xn, yn)]]
            return np.concatenate([X00, np.real(f), - np.imag(f), np.real(g), - np.imag(g), h], 1)

        
        # Coefficient of unkwown constant in ∂σh/∂x and ∂σh/∂y
        def σh_dxdy(x, y):
            # x:[x_1, x_2, x_3,,,x_number of calculation points] dtype = ndarray
            # y:[y_1, y_2, y_3,,,y_number of calculation points] dtype = ndarray
            
            npoint = len(x)  # number of calculation points

            X00 = np.full((npoint, 1), 0.)  # [[0.], [0.], [0.],,,[0.]]

            f = ((x / R) + 1j * (y / R))[:, np.newaxis] ** np.arange(M1)
            f2 = np.arange(1, M1 + 1) / R

            g = ((x[:, np.newaxis] / a - c[:, 0] / a) + 1j * (y[:, np.newaxis] / a - c[:, 1] / a))[:, :, np.newaxis] ** np.arange(- 2, - M2 - 2, - 1)
            g2 = np.arange(1, M2 + 1) / a[np.newaxis, :, np.newaxis]

            hx = (x[:, np.newaxis] - c[:, 0]) / ((x[:, np.newaxis] - c[:, 0]) ** 2 + (y[:, np.newaxis] - c[:, 1]) ** 2)

            hy = (y[:, np.newaxis] - c[:, 1]) / ((x[:, np.newaxis] - c[:, 0]) ** 2 + (y[:, np.newaxis] - c[:, 1]) ** 2)
            
            # σh_dx: 2d array [[Coefficients at (x1, y1)], [Coefficients at (x2, y2)],,,[Coefficients at (xn, yn)]]
            σh_dx = np.concatenate([X00, f2 * np.real(f), - f2 * np.imag(f), (- np.real(g) * g2).reshape(npoint, - 1), (np.imag(g) * g2).reshape(npoint, - 1), hx], 1)
            σh_dy = np.concatenate([X00, - f2 * np.imag(f), - f2 * np.real(f), (np.imag(g) * g2).reshape(npoint, - 1), (np.real(g) * g2).reshape(npoint, - 1), hy], 1)

            return σh_dx, σh_dy
        
        
        # Coefficient of unkwown constant in ∂σh/∂r
        def σh_dr(r, angle, x0, y0):
            npoint = len(angle)  # number of calculation points

            X00 = np.full((npoint, 1), 0.)

            f = ((r * np.cos(angle) + x0) / R + 1j * (r * np.sin(angle) + y0) / R)[:, np.newaxis] ** np.arange(M1) * (np.cos(angle) + 1j * np.sin(angle))[:, np.newaxis]
            f2 = np.arange(1, M1 + 1) / R

            g = (((r * np.cos(angle) + x0)[:, np.newaxis] - c[:, 0]) / a + 1j * ((r * np.sin(angle) + y0)[:, np.newaxis] - c[:, 1]) / a)[:, :, np.newaxis] **\
                np.arange(- 2, - M2 - 2, - 1) * (np.cos(angle) + 1j * np.sin(angle))[:, np.newaxis, np.newaxis]
            g2 = np.arange(1, M2 + 1) / a[np.newaxis, :, np.newaxis]

            h1 = ((r * np.cos(angle) + x0)[:, np.newaxis] - c[:, 0]) * np.cos(angle)[:, np.newaxis] +\
                ((r * np.sin(angle) + y0)[:, np.newaxis] - c[:, 1]) * np.sin(angle)[:, np.newaxis]
            h2 = ((r * np.cos(angle) + x0)[:, np.newaxis] - c[:, 0]) ** 2 + ((r * np.sin(angle) + y0)[:, np.newaxis] - c[:, 1]) ** 2

            return np.concatenate([X00, np.real(f) * f2, - np.imag(f) * f2, (- np.real(g) * g2).reshape(npoint, -1), (np.imag(g) * g2).reshape(npoint, -1), h1 / h2], 1)
        

        # Points of equation
        # Tips of voids  (# 1. Boundary conditions for stress at the tips of voids)
        θe = 2 * math.pi * np.arange(1, 1 + n_tip) / n_tip
        θm = 2 * math.pi * np.arange(0.5, 0.5 + n_tip) / n_tip

        void_tip = np.array([c[i] + a[i] * np.array([np.cos(θe), np.sin(θe)]).T for i in range(nv)])  # zcavity[void num] = [[x,y], [x,y], ,,,]
        void_tip_m = np.array([c[i] + a[i] * np.array([np.cos(θm), np.sin(θm)]).T for i in range(nv)])
        
        σh_ve = σh(void_tip.reshape(-1, 2)[:, 0], void_tip.reshape(-1, 2)[:, 1])
        σh_ve = σh_ve.reshape(nv, n_tip, - 1)

        σh_vm = σh(void_tip_m.reshape(-1, 2)[:, 0], void_tip_m.reshape(-1, 2)[:, 1])
        σh_vm = σh_vm.reshape(nv, n_tip, - 1)

        σhdr_ve = np.array([σh_dr(a[i], θe, c[i, 0], c[i, 1]) for i in range(nv)])
        σhdr_vm = np.array([σh_dr(a[i], θm, c[i, 0], c[i, 1]) for i in range(nv)])

        # Calculation points on the TLs. (# 2.1 Diffusion flux at TLs)
        segment_len = np.sum(TL_length0) / (n_TL + len(vtxc0))  # length per segment.
        segment_num = np.ceil(TL_length0 / segment_len).astype(int)  # number of division.
        segment_num[segment_num < 2] = 2  # less than 2 -> 2
        
        points_TL = [calc_dividing_points(p[0], p[1], num).tolist() for p, num in zip(vtxc0, segment_num)]
        

        # Calculation points on the TLs. (# 2.2 Diffusion flux at TLs)
        sim_TL = np.array([calc_dividing_points(p[0], p[1], n_sim) for p in vtxc0])  # Endpoints. Simpson's rule
        sim_TL_m = np.array([(sim_TL[i][:-1] + sim_TL[i][1:]) / 2 for i in range(nTL0)])  # Middle points. Simpson's rule

        σh_e = σh(sim_TL.reshape(-1, 2)[:, 0], sim_TL.reshape(-1, 2)[:, 1])
        σh_e = σh_e.reshape(nTL0, n_sim + 1, - 1)

        σh_m = σh(sim_TL_m.reshape(-1, 2)[:, 0], sim_TL_m.reshape(-1, 2)[:, 1])
        σh_m = σh_m.reshape(nTL0, n_sim, - 1)

        σhdx_e, σhdy_e = σh_dxdy(sim_TL.reshape(-1, 2)[:, 0], sim_TL.reshape(-1, 2)[:, 1])
        σhdx_e = σhdx_e.reshape(nTL0, n_sim + 1, - 1)
        σhdy_e = σhdy_e.reshape(nTL0, n_sim + 1, - 1)

        σhdx_m, σhdy_m = σh_dxdy(sim_TL_m.reshape(-1, 2)[:, 0], sim_TL_m.reshape(-1, 2)[:, 1])
        σhdx_m = σhdx_m.reshape(nTL0, n_sim, - 1)
        σhdy_m = σhdy_m.reshape(nTL0, n_sim, - 1)


        # 1. Boundary conditions for stress at the tips of voids
        # X1 : Coefficients of unknown constants.
        X1 = σh_ve  # X1[0 ~ nv-1] = [[coefficients], [coefficients], .., [coefficients]]
        
        # Y1 : - Special solution + Stress at the tips of voids
        Y1 = np.sum(void_tip ** 2, axis=2) * v_δ0 / (4 * D_GB_calc) + σ_tip[:, np.newaxis]  # Y1[0 ~ nv-1] = [value, value, ,,,value]
        
        X1N = X1 / σ_tip[:, np.newaxis, np.newaxis]
        Y1N = Y1 / σ_tip[:, np.newaxis]
        weight1 = np.full(n_tip * nv, 1. / np.sqrt(n_tip))
        

        # 2.1 Diffusion flux at TLs
        # calculate normal vector
        normal_vector = np.array([TL_vector[:,1], - TL_vector[:,0]]).T / TL_length0[:,np.newaxis]
        inner_product = np.sum(normal_vector * vtxc0[:,0], axis=1)
        normal_vector[inner_product < 0] *= - 1

        # calculate diffusion flux
        flux = Ω * np.sum(j_flux0.reshape(-1, 2), axis=1) / TL_length0

        def X21f(points_TLi, normal_vectori, sigma_tip_nexti):
            points_TLi = np.array(points_TLi)  # list -> array. points_TL_i = [[x1, y1], [x2, y2],,,[xn, yn]]
            if sigma_tip_nexti == 0:
                σh_dx, σh_dy = σh_dxdy(points_TLi[:,0], points_TLi[:,1])
                return (D_GB_calc * (normal_vectori[0] * σh_dx + normal_vectori[1] * σh_dy)).tolist()
            else:
                return (σh(points_TLi[:,0], points_TLi[:,1])).tolist()

        def y21f(fluxi, points_TLi, normal_vectori, sigma_tip_nexti):
            points_TLi = np.array(points_TLi)  # list -> array. points_TL_i = [[x1, y1], [x2, y2],,,[xn, yn]]
            if sigma_tip_nexti == 0:
                return (- D_GB_calc * (normal_vectori[0] * σ0_dx(points_TLi[:,0]) + \
                                    normal_vectori[1] * σ0_dy(points_TLi[:,1])) + fluxi).tolist()
            else:
                return - σ0(points_TLi[:,0], points_TLi[:,1]) + sigma_tip_nexti

        X21 = list(map(X21f, points_TL, normal_vector, sigma_tip_next))  # X2_1[0 ~ nTL-1] = [[coefficients], [coefficients], .., [coefficients]]
        y21 = list(map(y21f, flux, points_TL, normal_vector, sigma_tip_next))

        X21N = list(map(lambda x, y, z: (np.array(x) / (y if z == 0 else z)).tolist(), X21, flux, sigma_tip_next))
        y21N = list(map(lambda x, y, z: (np.array(x) / (y if z == 0 else z)).tolist(), y21, flux, sigma_tip_next))
        
        weight21 = np.full(sum(segment_num) + nTL0, math.sqrt(0.001 / (sum(segment_num) + nTL0)))


        # 2.2 Diffusion flux at TLs
        def simpson(end, middle, l):
            return np.sum(np.array([end[i] + end[i + 1] + 4 * middle[i] for i in range(n_sim)]), axis=0) * l / (6 * n_sim)

        def X22f(i):
            if sigma_tip_next[i] == 0:
                f_e = D_GB_calc * (normal_vector[i, 0] * σhdx_e[i] + normal_vector[i, 1] * σhdy_e[i])
                f_m = D_GB_calc * (normal_vector[i, 0] * σhdx_m[i] + normal_vector[i, 1] * σhdy_m[i])
            else:
                f_e = σh_e[i]
                f_m = σh_m[i]
            return simpson(f_e, f_m, TL_length0[i])
        
        def y22f(sim_TLi, sim_TL_mi, normal_vectori, sigma_tip_nexti, l):
            if sigma_tip_nexti == 0:
                f_e = - D_GB_calc * (normal_vectori[0] * σ0_dx(sim_TLi[:,0]) + normal_vectori[1] * σ0_dy(sim_TLi[:,1]))
                f_m = - D_GB_calc * (normal_vectori[0] * σ0_dx(sim_TL_mi[:,0]) + normal_vectori[1] * σ0_dy(sim_TL_mi[:,1]))
            else:
                f_e = - σ0(sim_TLi[:,0], sim_TLi[:,1]) + sigma_tip_nexti
                f_m = - σ0(sim_TL_mi[:,0], sim_TL_mi[:,1]) + sigma_tip_nexti
            return simpson(f_e, f_m, l)

        X22 = np.array([X22f(i) for i in range(nTL0)])
        y22 = np.array(list(map(y22f, sim_TL, sim_TL_m, normal_vector, sigma_tip_next, TL_length0))) + TL_length0 * flux

        X22N = np.array(list(map(lambda x, w, y, z: x / ((y if z == 0 else z) * w), X22, TL_length0, flux, sigma_tip_next)))
        y22N = np.array(list(map(lambda x, w, y, z: x / ((y if z == 0 else z) * w), y22, TL_length0, flux, sigma_tip_next)))

        weight22 = np.sqrt(TL_length0 / np.sum(TL_length0))

        
        # 3 Equilibrium of applied forces
        def X3f(i):
            f_e = (2 * sim_TL[i] @ normal_vector[i])[:, np.newaxis] * σh_e[i] - \
                np.sum(sim_TL[i] ** 2, axis=1)[:, np.newaxis] * (normal_vector[i, 0] * σhdx_e[i] + normal_vector[i, 1] * σhdy_e[i])
            f_m = (2 * sim_TL_m[i] @ normal_vector[i])[:, np.newaxis] * σh_m[i] - \
                np.sum(sim_TL_m[i] ** 2, axis=1)[:, np.newaxis] * (normal_vector[i, 0] * σhdx_m[i] + normal_vector[i, 1] * σhdy_m[i])
            return simpson(f_e, f_m, TL_length0[i]) / 4

        def simpson2(end, middle):
            return np.sum(np.array([end[i] + 2 * middle[i] for i in range(n_tip)]), axis=0) * 2 * math.pi / (3 * n_tip)   

        def X3cf(i):
            f_e = 2 * a[i] * (a[i] + c[i, 0] * np.cos(θe) + c[i, 1] * np.sin(θe))[:, np.newaxis] * σh_ve[i] -\
                (a[i] ** 2 + 2 * c[i, 0] * a[i] * np.cos(θe) + 2 * c[i, 1] * a[i] * np.sin(θe) + c[i, 0] ** 2 + c[i, 1] ** 2)[:, np.newaxis] *\
                    σhdr_ve[i] * a[i]
            f_m = 2 * a[i] * (a[i] + c[i, 0] * np.cos(θm) + c[i, 1] * np.sin(θm))[:, np.newaxis] * σh_vm[i] -\
                (a[i] ** 2 + 2 * c[i, 0] * a[i] * np.cos(θm) + 2 * c[i, 1] * a[i] * np.sin(θm) + c[i, 0] ** 2 + c[i, 1] ** 2)[:, np.newaxis] *\
                    σhdr_vm[i] * a[i]

            return simpson2(f_e, f_m) / 4

        def y3f(p1, p2):
            # (x1*x1 + y1*y1 + x2*x2 + y2*y2 + x1*x2 + y1*y2) * |x1*y2 - y1*x2|
            return (np.dot(p1, p1) + np.dot(p2, p2) + np.dot(p1, p2)) * abs(np.cross(p1, p2))

        X3 = np.sum(np.array([X3f(i) for i in range(nTL0)]), axis=0) - np.sum(np.array([X3cf(i) for i in range(nv)]), axis=0)
        Y3 = np.dot(σ.T @ GBF_nv0, GBF_nv0) * S0 + sum([y3f(x[0], x[1]) for x in vtxc0]) * v_δ0 / (48 * D_GB_calc) -\
            np.sum(a ** 4 + 2 * np.array([np.dot(x, x) for x in c]) * a ** 2) * math.pi * v_δ0 / (8 * D_GB_calc)

        X3N = X3 / (np.dot(σ.T @ GBF_nv0, GBF_nv0) * S0)
        Y3N = Y3 / (np.dot(σ.T @ GBF_nv0, GBF_nv0) * S0)

        weight3 = np.array([1 + nv])  # No meaning.


        # Caluculate unknown constant.
        n = 1 + 2 * M1 + 2 * M2 * nv + nv
        XallN = np.concatenate([X1N.reshape(-1, n), np.array([item for sublist in X21N for item in sublist]), X22N, X3N.reshape(-1, n)])
        yallN = np.concatenate([Y1N.flatten(), np.array([item for sublist in y21N for item in sublist]), y22N.flatten(), np.array([Y3N])])

        erow = - 1
        ecolumn = 0

        Xcalc = (XallN - XallN[erow] * (XallN[:, ecolumn] / XallN[erow, ecolumn])[:, np.newaxis])[:erow, ecolumn + 1:]
        ycalc = (yallN - yallN[erow] * (XallN[:, ecolumn] / XallN[erow, ecolumn]))[:erow]
        wcalc = np.diag(np.concatenate((weight1, weight21, weight22, weight3)))[:erow, :erow]

        bbcalc = np.linalg.inv(Xcalc.T @ wcalc @ Xcalc) @ Xcalc.T @ wcalc @ ycalc
        bb = np.insert(bbcalc, ecolumn, (yallN[erow] - np.dot(bbcalc, XallN[erow, ecolumn + 1:])) / XallN[erow, ecolumn])


        # Calculate volume change rate
        def Vrate_ntipf(i):
            x = σhdr_ve[i]
            f_e = np.insert(x, 0, x[-1], axis=0)
            f_m = σhdr_vm[i]
            return (D_GB_calc * a[i] * math.pi / (3 * n_tip)) * np.array([f_e[j] + f_e[j + 1] + 4 * f_m[j] for j in range(n_tip)]) @ bb
        
        def Vrate_ntipg(i):
            x = σ0_dr(a[i], θe, c[i, 0], c[i, 1])
            f_e = np.insert(x, 0, x[-1], axis=0)
            f_m = σ0_dr(a[i], θm, c[i, 0], c[i, 1])
            return (D_GB_calc * a[i] * math.pi / (3 * n_tip)) * np.array([f_e[j] + f_e[j + 1] + 4 * f_m[j] for j in range(n_tip)])

        
        Vrate_ntip = np.array([Vrate_ntipf(i) for i in range(nv)]) + np.array([Vrate_ntipg(i) for i in range(nv)])
        Vrate_ntip_sum = np.sum(Vrate_ntip, axis=1)
        Vrate = Vrate_ntip_sum + math.pi * a ** 2 * v_δ0
        move_rate = Vrate_ntip / np.abs(Vrate_ntip_sum)[:, np.newaxis]  # move_rate[k, l] = V_k,l / V_k

        # update voids' shape
        tempV = V + Vrate * Δt * ntime
        tempψ, temph ,tempc = ψ, h, c

        for i in range(nv):
            if tempV[i] < V_calc1:
                tempV[i] = tempψ[i] = temph[i] = tempc[i, 0] = tempc[i, 1] = np.nan
            
            elif tempV[i] < h[i] ** 3 * V_calc2:  # Become a sphere
                temph[i] = (tempV[i] * h_calc) ** (1 / 3)
                tempψ[i] = math.pi / 2 - ϕ
            
            else: # h is constant
                tempψ[i] = math.asin(
                        (3 + math.sqrt(9 + 8 * (3 * math.tan(ϕ) ** 2 * tempV[i] / (2 * math.pi * h[i] ** 3) - 1))) /
                        (2 * (3 * math.tan(ϕ) ** 2 * tempV[i] / (2 * math.pi * h[i] ** 3) - 1)))

        tempβ = temph / (1 - np.sin(tempψ))
        tempα = tempβ / (math.tan(ϕ) * np.tan(tempψ))
        tempa = (tempβ * np.cos(tempψ)) / (math.tan(ϕ) * np.tan(tempψ))
        Δa = tempa - a


        # calculate change in the void center coordinates
        Δzkl = move_rate[:, :, np.newaxis] * np.array([np.cos(θm), np.sin(θm)]).T[np.newaxis, :, :] * np.abs(Δa)[:, np.newaxis, np.newaxis] / 2
        Δz = np.sum(Δzkl, axis=1)
        tempc = Δz + tempc


        # Surface diffusion
        # calculate a
        tempa = aratef(tempα, tempβ, tempψ) / math.sin(ϕ) * Δt + tempa
        compare = (tempV / a_calc) ** (1 / 3)
        tempa = np.maximum(tempa, compare)

        # calculate ψ, β
        tempψ = np.arcsin((-(1 - ψ_calc * tempV / tempa ** 3) + np.sqrt(1 - ψ_calc * tempV / tempa ** 3)) / (1 - ψ_calc * tempV / tempa ** 3))
        tempβ = math.tan(ϕ) * np.tan(tempψ) * tempa / np.cos(tempψ)

        # delete np.nan. array -> list
        newa = tempa[~np.isnan(tempa)].tolist()
        newc = tempc[~np.isnan(tempc)].reshape(-1, 2).tolist()
        newβ = tempβ[~np.isnan(tempβ)].tolist()
        newθ = tempψ[~np.isnan(tempψ)].tolist()

        result = [[newa[i], newc[i], newβ[i], newθ[i]] for i in range(len(newa))]
        return result

    void_temp = [growth(i) for i in range(nGBF)]


    # calculate the growth of voids through extrapolation
    def extrapolation(GBFi):  # GBFi: GBF id - 1
        if GBF_state[is_ + 1, GBFi] != 2:
            return void_temp[GBFi]
        
        ω_GBF0 = ω_GBF[:is_ + 1, GBFi]
        data = np.insert(ω_GBF0[ω_GBF0 != 0], 0, 0.0)
        ndata = len(data)

        x_values = np.arange(1, ndata + 1)
        y_values = data

        if ndata == 1:
            # print('1 data!')
            extraplotaion = 1.
        elif ndata == 2:
            f = interp1d(x_values, y_values, kind='linear', fill_value="extrapolate")
            extraplotaion = f(ndata + 1)
        elif ndata == 3:
            f = interp1d(x_values, y_values, kind='quadratic', fill_value="extrapolate")
            extraplotaion = f(ndata + 1)
        else:
            f = interp1d(x_values[-4:], y_values[-4:], kind='cubic', fill_value="extrapolate")
            extraplotaion = f(ndata + 1)

        if extraplotaion >= 1:
            GBF_state[is_ + 1:, GBFi] = 3
            # print(f"{GBFi} ω = 1.0")

            newa = math.sqrt(GBF_s[is_ + 1, GBFi] / math.pi)
            newθ = min([row[3] for row in void_temp[GBFi]])
            newβ = math.tan(ϕ) * math.tan(newθ) * newa / math.cos(newθ)

            GBF_next_status[GBF_next_id == GBFi + 1] = (γ_s * math.tan(ϕ) * math.tan(newθ) / newβ) * (math.sin(ϕ) / math.cos(newθ)) * (1 + math.cos(ϕ) ** 2 / math.sin(newθ) ** 2)

            return [[newa, [0, 0], newβ, newθ]]
        
        compare = (f(ndata + 1) - f(ndata)) - (f(ndata) - f(ndata - 1))

        if compare < 0:
            newa = math.sqrt(GBF_s[is_ + 1, GBFi] * (f(ndata) + f(ndata) - f(ndata - 1)) / math.pi)
        else:
            newa = math.sqrt(GBF_s[is_ + 1, GBFi] * f(ndata + 1) / math.pi)
        
        newθ = min([row[3] for row in void_temp[GBFi]])
        newβ = math.tan(ϕ) * math.tan(newθ) * newa / math.cos(newθ)

        return [[newa, [0, 0], newβ, newθ]]

    void_temp = [extrapolation(i) for i in range(nGBF)]


    # Separate voids that have come too close
    def separation(GBFi):  # GBFi: GBF id - 1
        global check
        if GBF_state[is_ + 1, GBFi] != 1:
            return void_temp[GBFi]
        
        if len(void_temp[GBFi]) <= 1:
            return void_temp[GBFi]
        
        temp = void_temp[GBFi]
        nv = len(temp)

        # void_dist: check distance between voids. If value is 1, move void.
        void_dist = np.zeros((nv, nv), dtype=int)

        # cavdistf: function that update void_dist
        def void_distf(i, j):
            if i >= j:
                void_dist[i, j] = 0
                return

            if np.linalg.norm(np.array(temp[i][1]) - np.array(temp[j][1])) > temp[i][0] + temp[j][0] + aini:
                void_dist[i, j] = 0
            else:
                void_dist[i, j] = 1
            return
        
        # update void_dist
        for i in range(nv):
            for j in range(nv):
                void_distf(i, j)

        # If all value is 0, don't move any void.
        if np.sum(void_dist) == 0:
            return temp

        check = 1

        SPiteration = 0

        while np.sum(void_dist) != 0:
            positions = np.where(void_dist != 0)
            i = positions[0][0]  # void number that need to separate each other
            j = positions[1][0]  # void number that need to separate each other

            distance = np.linalg.norm(np.array(temp[i][1]) - np.array(temp[j][1]))

            # calculate length of movement
            move_i = 0.5 * (temp[i][0] + temp[j][0] + 2 * aini - distance) * \
                (np.array(temp[i][1]) - np.array(temp[j][1])) / distance
            move_j = - move_i

            temp[i][1] = (np.array(temp[i][1]) + move_i).tolist()
            temp[j][1] = (np.array(temp[j][1]) + move_j).tolist()

            for i in range(nv):
                for j in range(nv):
                    void_distf(i, j)

            SPiteration += 1

            if SPiteration == 500:
                # print(f"{GBFi} SP")
                GBF_state[is_ + 1:, GBFi] = 2
                break

        return temp


    # Move voids that have exited TL back inside the TL
    def growbeyondtl(GBFi):
        global check

        vtxc0 = GBF_vtxc[is_ + 1, GBFi, ~np.isnan(GBF_vtxc[is_ + 1, GBFi])].reshape(-1, 2, 2)  # Vertices coordinates.
        nTL0 = len(vtxc0)
        temp = void_temp[GBFi]
        nv = len(temp)
        
        if GBF_state[is_ + 1, GBFi] != 1:
            return temp

        if nv == 0:
            return temp

        def plfoot(x, p1, p2):  # Foot of the perpendicular.
            t = (np.dot(p1 - x, p1 - x) - np.dot(p1 - x, p2 - x)) / np.dot(p1 - p2, p1 - p2)
            return p1 + t * (p2 - p1)
        
        # H : foot of prependicular. H = [[x, y], [x, y],,,]
        H = np.array([plfoot([0.0, 0.0], x[0], x[1]) for x in vtxc0])

        # OH : distance from origin to H 
        OH = np.array([np.linalg.norm(h) for h in H])
        p = 0.99  # Tolerance value
        pOH = p * OH

        a = np.array([sublist[0] for sublist in temp]) # radius of voids

        f = OH - a[:, np.newaxis]  # OH - radius. 2darray. row: void. column: TL
        f2 = pOH - a[:, np.newaxis]  # p * OH - radius. 2darray. row: void. column: TL

        # function that caluculate production vector.
        def pvector(i):  # i: 0 ~ nv-1
            c = np.array(temp[i][1])  # center coordinates of void i. c = [x, y].
            return H @ c / OH  # 1darray. [val, val,,,]

        # If check_cavity_tl > 0, void is out of GBF.
        def check_cavity_tl(i):  # i: 0 ~ nv-1
            return pvector(i) - f[i]  # production vector + radius - OH. 1darray. [val, val,,,]

        def move_cavity(i):  # i: 0 ~ nv-1
            TLiteration = 0

            while max(check_cavity_tl(i)) > 0:
                target_TL = np.argmax(check_cavity_tl(i))
                c = np.array(temp[i][1])
                temp[i][1] = (c * f2[i, target_TL] / pvector(i)[target_TL]).tolist()

                TLiteration += 1
                if TLiteration == 500:
                    # print(GBFi, "TL")
                    GBF_state[is_ + 1:, GBFi] = 2
                    break

        for i in range(nv):
            if max(check_cavity_tl(i)) > 0:
                move_cavity(i)
                check = 1

        return temp


    for i in range(nGBF):
        check = 0
        void_temp[i] = separation(i)
        void_temp[i] = growbeyondtl(i)

        SPTLiteration = 0

        while check != 0:
            check = 0
            void_temp[i] = separation(i)
            void_temp[i] = growbeyondtl(i)
            SPTLiteration = SPTLiteration + 1

            if SPTLiteration == 500:
                # print(i, "SP+TL")
                GBF_state[is_ + 1:, i] = 2
                break


    # Update the shape of void on GBF with a void area fraction of 1
    def extrapolation2(GBFi):  # GBFi = GBF id - 1
        temp = void_temp[GBFi]
        if GBF_state[is_ + 1, GBFi] != 3:
            return temp
        
        newa = math.sqrt(GBF_s[is_ + 1, GBFi] / math.pi)
        newθ = temp[0][3]
        newβ = math.tan(ϕ) * math.tan(newθ) * newa / math.cos(newθ)

        return [[newa, [0, 0], newβ, newθ]]

    void[is_ + 1] = [extrapolation2(i) for i in range(nGBF)]


    # calculate number of voids
    nvoid[is_ + 1] = np.array([len(void[is_ + 1][i]) for i in range(nGBF)])


    # calculate area fraction
    temp_ω_all = 0.

    for i in range(nGBF):
        if nvoid[is_ + 1, i] == 0:
            ω_GBF[is_ + 1, i] = 0.

        else:
            void_area = sum([math.pi * element[0] ** 2  for element in void[is_ + 1][i]])
            
            ω_GBF[is_ + 1, i] = void_area / GBF_s[is_ + 1, i]
            temp_ω_all += void_area

    ω_all[is_ + 1] = temp_ω_all / sum(GBF_s[is_ + 1])


for is_ in range(step):
    print(is_ + 1, "/", step)
    execution(is_)

result = ['simulation result','time [h]'] + (Δt * np.arange(step + 1) / 60 ** 2).tolist() + ['strain (e_yy) [-]'] + ϵ[:,1,1].tolist() + ['void area fraction [-]'] + ω_all.tolist()
with open("result.dat", "w") as o:
    print(*result, sep="\n",file=o)
